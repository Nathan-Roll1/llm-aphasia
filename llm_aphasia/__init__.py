import torch
from typing import Optional, Dict, List, Union
import warnings

from .models import get_model_and_tokenizer
from .core import (
    get_target_modules,
    save_weights,
    restore_weights,
    apply_ablation_to_model,
    generate_text,
)
from .targeted import targeted_ablate

# Global state to manage ablations applied to cached models
_ABLATION_STATE: Dict[str, Dict] = {}

def ablate(
    model_path: str,
    ablation_strategy: str,
    severity: float,
    text_input: str,
    random_seed: int = 42,
    max_new_tokens: int = 50,
) -> str:
    """
    High-level wrapper to load a model, apply an ablation, and generate text.

    Manages model caching and state to ensure computational efficiency.

    Args:
        model_path (str): The name or path of the Hugging Face model.
        ablation_strategy (str): The ablation strategy to apply.
            Options: 'zero_out', 'mean_out', 'swap_x', 'swap_y', 
            'shuffle_x', 'shuffle_y', 'global', 'unablated'.
        severity (float): The degree of ablation, from 0.0 (none) to 1.0 (maximum).
        text_input (str): The prompt to send to the model.
        random_seed (int): Seed for reproducibility of random ablations.
        max_new_tokens (int): The maximum number of new tokens to generate.

    Returns:
        The text generated by the (potentially ablated) model.
    """
    # Validate inputs
    if not (0.0 <= severity <= 1.0):
        raise ValueError("Severity must be between 0.0 and 1.0.")
    
    valid_strategies = ['zero_out', 'mean_out', 'swap_x', 'swap_y', 'shuffle_x', 'shuffle_y', 'global', 'unablated']
    if ablation_strategy not in valid_strategies:
        raise ValueError(f"Invalid ablation strategy '{ablation_strategy}'. Must be one of: {valid_strategies}")
    
    if ablation_strategy == 'unablated':
        severity = 0.0

    # 1. Get model from cache or load it
    try:
        model, tokenizer = get_model_and_tokenizer(model_path)
    except Exception as e:
        raise RuntimeError(f"Failed to load model '{model_path}': {str(e)}")
    
    # 2. Check current state and determine if changes are needed
    current_state = _ABLATION_STATE.get(model_path)
    new_state_is_different = (
        not current_state or
        current_state['strategy'] != ablation_strategy or
        current_state['severity'] != severity or
        current_state['seed'] != random_seed
    )

    if new_state_is_different:
        # Restore model to its original, pristine state if it was previously ablated
        if current_state and 'original_weights' in current_state:
            print("Restoring original weights...")
            try:
                restore_weights(current_state['original_weights'])
            except Exception as e:
                warnings.warn(f"Failed to restore weights: {str(e)}. Continuing with current weights.")

        # Apply new ablation if the strategy is not 'unablated'
        if severity > 0:
            print(f"Applying new ablation: strategy='{ablation_strategy}', severity={severity}")
            
            # Get target modules
            target_modules = get_target_modules(model)
            if not target_modules:
                warnings.warn("No target modules found for ablation. Returning unablated output.")
                severity = 0
            else:
                # Save original weights
                original_weights = save_weights(target_modules)
                
                # Determine device
                device = next(model.parameters()).device
                generator = torch.Generator(device=device).manual_seed(random_seed)

                # Apply ablation
                try:
                    apply_ablation_to_model(
                        target_modules=target_modules,
                        strategy=ablation_strategy,
                        severity=severity,
                        generator=generator
                    )
                    
                    # Store the new state
                    _ABLATION_STATE[model_path] = {
                        'strategy': ablation_strategy,
                        'severity': severity,
                        'seed': random_seed,
                        'original_weights': original_weights,
                    }
                except Exception as e:
                    # Restore weights if ablation failed
                    restore_weights(original_weights)
                    raise RuntimeError(f"Failed to apply ablation: {str(e)}")
        else:
            # The new state is unablated, just clear the old state
            if model_path in _ABLATION_STATE:
                del _ABLATION_STATE[model_path]

    # 3. Model is now in the correct state, generate text
    try:
        output = generate_text(model, tokenizer, text_input, max_new_tokens)
    except Exception as e:
        raise RuntimeError(f"Failed to generate text: {str(e)}")
    
    return output

# Export main functions
__all__ = ['ablate', 'targeted_ablate']
